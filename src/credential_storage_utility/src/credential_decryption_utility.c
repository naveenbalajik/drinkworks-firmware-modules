/**
 * @file credential_decryption_utility.c
 *
 * Created on: May 20, 2020
 * 		Author: nick.weber
 */

/* AES encryption/decryption */
#include "mbedtls/aes.h"

/* Standard includes. */
#include <string.h>

/* credential decryption */
#include "credential_decryption_utility.h"

/* Platform layer includes. */
#include "esp_err.h"

/* FreeRTOS includes. */
#include "FreeRTOS.h"

/* Code signing cert include */
#include "aws_ota_codesigner_certificate.h"

/* NVS storage utility */
#include "pkcs11_cred_storage_utility.h"
#include "nvs_utility.h"

/* Debug Logging */
#include "credential_logging.h"

#define ENCRYPTION_KEY_LENGTH					(32)

#define	ENCRYPTION_IV_LENGTH					(16)

#define AES_KEY_SIZE_BITS						(256)

#define END_OF_CERTIFICATE_STRING	"-----END CERTIFICATE-----\n"

#define END_OF_PRIV_KEY_STRING		"-----END RSA PRIVATE KEY-----\n"

#define credentialsSTORAGE_PARTITION	"storage"

#define credentialsSTORAGE_NS			"creds"

/**
 * @brief Decryption key used for AES decryption is stored in a header file and generated by the encryptor utility.
 *
 * Key is obfuscated with the highest bit of every other byte swapped
 */
static unsigned char decryptionKey[ENCRYPTION_KEY_LENGTH] = {
#include "obfuscatedEncryptionKey.h"
};

/**
 * @brief Decryption IV used for AES CBC decryption is stored in a header file and generated by the encryptor utility.
 *
 * Key is obfuscated with the highest bit of every other byte swapped
 */
static unsigned char decryptionIV[ENCRYPTION_IV_LENGTH] = {
#include "obfuscatedEncryptionIV.h"
};

/**
 * @brief Encrypted claim certificate stored in header file generated by the encryptor utility
 *
 * Certificate is encrypted using AES cbc encryption with a 256 bit key
 */
static unsigned char encryptedClaimCert[CLAIM_CERT_ENCRYPTED_BYTE_LENGTH] = {
#include "encryptedCertificate.h"
};

/**
 * @brief Encrypted claim private key stored in header file generated by the encryptor utility
 *
 * private key is encrypted using AES cbc encryption with a 256 bit key
 */
static unsigned char encryptedClaimPrivKey[CLAIM_PRIVKEY_ENCRYPTED_BYTE_LENGTH] = {
#include "encryptedPrivateKey.h"
};

static unsigned char encryptedCodeSignCert[CODE_SIGN_CERT_ENCRYPTED_BYTE_LENGTH] = {
#include "encryptedCodeSigningCert.h"
};

/**
 * @brief Flip every Nth bit of an array
 *
 * @param[in/out] pObfuscatedMemory array to alter
 * @param[in] length length of array
 * @param[in] nBit bit of byte to flip. Should be between 0-7
 * @param[in] nBytes bytes frequency to flip. 1 will flip every byte, 2 will flip every other byte, 3 every 3rd byte, etc.
 */
static void _flipEveryNthBitofNBytes(unsigned char * pObfuscatedMemory, unsigned int length, unsigned char nBit, unsigned int nBytes)
{
	unsigned char mask = 1 << nBit;
	int i;

	for(i=0; i<length; i+=nBytes){
		pObfuscatedMemory[i] ^= mask;
	}
}

/**
 * @brief Decrypt the claim credentials
 *
 * Claim credentials are AES encrypted before being defined in code. This is to remove the possibility of a
 * bad actor parsing the hex file and reading the claim credentials. This function decrypts the credentials
 *
 * @return ESP_OK upon successful credential setup.
 * Otherwise, a positive PKCS #11 error code.
 */
int32_t credentialUtility_decryptCredentials(void)
{
	static bool decryptionComplete = 0;

	if( decryptionComplete )
	{
		IotLogInfo( "Decryption of credentials already completed. Exiting decryption function" );
		return ESP_OK;
	}
	decryptionComplete = 1;

	esp_err_t err;
	mbedtls_aes_context aes;
	int i;
	char endOfStringFound = 0;
	unsigned char ivClaimCredsCopy[ENCRYPTION_IV_LENGTH];
	unsigned char ivClaimCredsCopy2[ENCRYPTION_IV_LENGTH];

	// un-obfuscate key and iv. A simple obfuscation scheme where every other bit is flipped is used for the key and IV
	_flipEveryNthBitofNBytes( decryptionKey, ENCRYPTION_KEY_LENGTH, 7, 2 );
	_flipEveryNthBitofNBytes( decryptionIV, ENCRYPTION_IV_LENGTH, 7, 2 );

	// Use the same IV for the certificate,private key, and code signing cert. Since the IV is updated after every call to mbedtls_aes_crypt_cbc(), we need to copy the IV before it is modified
	memcpy( ivClaimCredsCopy, decryptionIV, ENCRYPTION_IV_LENGTH );
	memcpy( ivClaimCredsCopy2, decryptionIV, ENCRYPTION_IV_LENGTH );

	// Set up mbedtls aes context for decryption using defined key
	err = mbedtls_aes_setkey_enc( &aes, decryptionKey, AES_KEY_SIZE_BITS );

	// Decrypt claim certificate
	if( err == ESP_OK )
	{
		err = mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_DECRYPT, CLAIM_CERT_ENCRYPTED_BYTE_LENGTH, decryptionIV, encryptedClaimCert, plaintextClaimCert );
	}
	// Determine size of claim certificate
	if( err == ESP_OK )
	{
		for( i = ( CLAIM_CERT_ENCRYPTED_BYTE_LENGTH - sizeof( END_OF_CERTIFICATE_STRING ) ); i >= 0; i-- )
		{
			if( memcmp( &END_OF_CERTIFICATE_STRING, &plaintextClaimCert[i], sizeof( END_OF_CERTIFICATE_STRING ) - 1 ) == 0 )
			{
				endOfStringFound = 1;
				// mbedtls library requires end of credentials to be null terminated. Replace the \n found after "-----END CERTIFICATE----\n" with a 0
				plaintextClaimCert[i + sizeof(END_OF_CERTIFICATE_STRING) - 2] = 0;
				claimCertLength = i + sizeof(END_OF_CERTIFICATE_STRING) - 1;
				break;
			}
		}
	}
	else
	{
		IotLogError( "ERROR: mbedtls decryption failure for claim certificate" );
		return -1;
	}

	if( !endOfStringFound )
	{
		IotLogError( "ERROR: Certificate decryption error. End of certificate not found" );
		err = -1;
		return -1;
	}

	// Decrypt claim private key
	endOfStringFound = 0;
	if( err == ESP_OK )
	{
		err = mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_DECRYPT, CLAIM_PRIVKEY_ENCRYPTED_BYTE_LENGTH, ivClaimCredsCopy, encryptedClaimPrivKey, plaintextClaimPrivKey );
	}

	// Determine size of claim private key
	if( err == ESP_OK )
	{
		for( i = ( CLAIM_PRIVKEY_ENCRYPTED_BYTE_LENGTH - sizeof( END_OF_PRIV_KEY_STRING ) ); i >= 0; i-- )
		{
			if( memcmp( &END_OF_PRIV_KEY_STRING, &plaintextClaimPrivKey[i], sizeof( END_OF_PRIV_KEY_STRING ) - 1 ) == 0 )
			{
				endOfStringFound = 1;
				// mbedtls library requires end of private key to be null terminated. Replace the \n found after "-----END RSA PRIVATE KEY-----\n" with a 0
				plaintextClaimPrivKey[i + sizeof( END_OF_PRIV_KEY_STRING ) - 2] = 0;
				claimPrivKeyLength = i + sizeof( END_OF_PRIV_KEY_STRING ) - 1;
				break;
			}
		}
	}
	else
	{
		IotLogError( "ERROR: mbedtls decryption failure for claim private key" );
		return -1;
	}

	if( !endOfStringFound )
	{
		IotLogError( "ERROR: Private Key decryption error. End of Private Key not found" );
		return -1;
	}
	
	// Decrypt code sign key
	endOfStringFound = 0;
	if( err == ESP_OK )
	{
		err = mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_DECRYPT, CODE_SIGN_CERT_ENCRYPTED_BYTE_LENGTH, ivClaimCredsCopy2, encryptedCodeSignCert, plaintextCodeSignCert );
	}
	// Determine size of code sign key
	if( err == ESP_OK )
	{
		for( i = ( CODE_SIGN_CERT_ENCRYPTED_BYTE_LENGTH - sizeof( END_OF_CERTIFICATE_STRING ) ); i >= 0; i-- )
		{
			if( memcmp( &END_OF_CERTIFICATE_STRING, &plaintextCodeSignCert[i], sizeof( END_OF_CERTIFICATE_STRING ) - 1 ) == 0 )
			{
				endOfStringFound = 1;
				codeSignCertLength = i + sizeof( END_OF_CERTIFICATE_STRING ) - 1;
				break;
			}
		}
	}
	else
	{
		IotLogError( "ERROR: mbedtls decryption failure for code signing cert" );
		return -1;
	}

	if( !endOfStringFound )
	{
		IotLogError( "ERROR: Code signing cert decryption error. End of code signing cert not found" );
		return -1;
	}

	return err;
}
